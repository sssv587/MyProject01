C程序运行机制(过程)简述:
1)编辑：比如我们编写hello.c文件，就是源代码
2)编译：将hello.c程序翻译成目标文件(hello.obj)//在计算机底层执行
3)链接：将目标文件hello.obj+库文件生成可执行文件(MyProject01.exe) //在计算机底层执行
4)运行：执行.exe文件，得到运行结果

C常用的转义字符:
1)\t:一个制表位，实现对齐的功能
2)\n:换行符
3)\\:一个\
4)\":一个"
5)\':一个'
6)\r:一个回车 printf("张无忌赵敏周\r芷若小昭")

C语言包括的数据类型:
1.基本类型:
1)数值类型:
  整形:短整形(short),整形(int),长整形(long)
  浮点型:单精度浮点型(float),双精度浮点型(double)
2)字符类型:char
2.构造类型:
1)数组
2)结构体  struct
3)共用体  union
4)枚举类型 enum

3.指针类型
4.空类型

注意:
1.在c中，没有字符串类型函数，使用字符数组表示
2.在不同系统上，部分数据类型字节长度不一样，int 2或者4

bit(位):计算机中的最小存储单位。byte(字节):计算机中基本存储单元
1 byte = 8 bit[举个简单的例子short 2和int 3]

各种类型的存储大小与操作系统、系统位数和编译器有关，目前以64位为主

浮点型分类:
float单精度：4个字节，精确到6位小数
double双精度：8个字节，精确到15位小数
1)关于浮点数在及其中存放形式的简单说明，浮点数=符号位+指数位+尾数位，浮点数是近似值
2)尾数部分可能丢失，造成精度缺失

printf("d1=%f",d1)//在输出时，默认保留小数点6位

字符型
1)字符型存储到计算机中，需要将字符对应的码值(整数)找出来
存储:字符'a' --> 码值(97) --> 二进制(11000001) --> 存储
读取:二进制(11000001) --> 码值(97) --> 字符'a' --> 读取(显示)
2)字符和码值的对应关系是通过字符编码表决定的(是规定好)
ASCII码表只能表示2^7 127个字符 第一位统一是0

基本数据类型转换:
精度从低到高的顺序:short -> int -> unsigned int -> long -> unsigned long -> float -> double -> long double
数据类型自动转换:
高级
 ^
 |        double     <-------- float
 |          ^
 |          |
 |        long
 |          ^
 |          |
 |       unsigned
 |          ^
 |          |
低级       int    <----   char,short

1)有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度最大的那种数据类型，
然后再进行计算(如int型和short型运算时，先把short转成int型然后再进行运算)
2)若两种类型的字节数不同，准换成字节数较大的类型，若两种类型的字节数相同，且一种
有符号，一种无符号，则转换成无符号类型
3)在赋值运算中，赋值号两边的数据类型不同时，赋值号右边的类型将转换为左边的类型，
如果右边变量的数据类型比左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入
向前舍入

强制类型转换:
将精度高的数据类型转换为精度低的数据类型，使用时要加上强制转换符(),但可能造成精度降低或溢出，格外要注意
一般格式:(类型名)表达式

值传递和地址传递
C语言传递参数(或者赋值)可以是值传递，也可以是传递指针，传递指针也叫地址传递
1)默认传递值的类型:基本数据类型(整形类型、小数类型、字符类型)，结构体，共用体
2)默认传递地址的类型:指针、数组
预处理器

定义常量的两种方式:
1)使用#define
#define 常量名 常量值;
define后面可以不加分号
2)使用const关键字
const 数据类型 常量名 = 常量值;
const后面必须加分号

define和const区别
1)const定义常量时，带类型，define不带类型
2)const是在编译、运行的时候起作用，而define是在编译的预处理阶段起作用
3)define只是简单的替换，没有类型检查。简单的字符串替换会导致边界效应
4)const常量是可以进行调试的，define是不能进行调试的，主要是预编译阶段就已经替换掉了，调试的时候就没有它了
5)const不能重定义，不可以定义两个一样的，而define通过undef取消某个符号的定义，再重新定义
6)define可以配合#ifdef、#ifndef、#endif来使用，可以让代码更加灵活，比如我们可以通过#define来启动或者关闭调试信息

运算符
1)算术运算符(+,-,*,/,%)
2)赋值运算符(= += -= ..)
3)关系运算符(比较运算符)(比如 > >= < <= ==等等)
4)逻辑运算符(&& 逻辑与 || 逻辑或 ！逻辑非)
5)位运算符  (& 按位与 | 按位或 ^ 按位异或 ~按位取反)
6)三元运算符(表达式?表达式1:表达式2)

运算符优先级小结
1)结合的方向只有三个是从右向左，其余都是从左向右
2)所有的双目运算符只有赋值运算符的结合方向是从右向左
3)另外两个从右向左的结合运算符，一个是单目运算，还有一个是三目运算
4)逗号的运算符优先级最低
5)说一下优先级的大概的顺序 算术运算符 > 关系运算符 > 逻辑运算符(逻辑非!除外) > 赋值运算符 > 逗号运算符
6)注意不需要刻意的记，常用就慢慢有印象了

原码、反码、3补码
1)二进制的最高位是符号位:0表示正数，1表示负数
2)正数的原码、反码、补码都一样(三码合一)
3)负数的反码=它的原码符号位不变，其他位取反(0->1,1->0)
4)负数的补码=它的反码+1
5)0的反码，补码都是0
6)在计算机运算的时候，都是以补码的方式来运算的

算数右移:低位溢出，符号位不变，并用符号位补溢出的高位
算数左移:符号位不变，低位补0

程序流程控制:
1)顺序控制:程序从上到下逐行地执行，中间没有任何判断和跳转
2)分支控制:if-else
3)循环控制:

switch分支结构
switch(表达式){
   case 常量1://当表达式 值等于常量1执行语句块1;
   break; //退出switch
   case 常量2://当语句块2;
      break;
   ....
   case 常量n://当语句块n;
      break;
      default t:
      default t语句块;
      break;
}

循环遍历定义
for(1.循环变量初始化;2.循环条件;4.循环变量迭代){
    3.循环操作
}

1.循环变量初始化
while(2.循环条件){
    3.循环体(多条语句);
    4.循环遍历迭代;
}

do..while
1.循环变量初始化
do{
   2.循环体(多条语句)
   3.循环变量迭代
}while(4.循环条件);
注意:do-while后面有一个分号，不能省略

跳转控制语句-goto
1)C语言的goto语句可以无条件的转移到程序中指定的行
2)goto语句通常与条件语句配合使用，可用来实现条件转移，跳出循环体等功能
3)在C程序设计中一般不主张使用goto语句，以免造成程序流程的混乱，使理解和调试程序都产生困难

基本语法:
goto label
....
label:statement

枚举类型:
1)第一个枚举成员的默认值为整形的0，后续枚举成员的值在前一个成员上加1
2)在定义枚举元素的时改变枚举元素的值
3)枚举变量的定义的形式1-先定义枚举类型，再定义枚举变量
4)枚举变量的定义的形式2-先定义枚举类型的同时定义枚举变量
enum DAY{
  MON =1,TUE,WED,THU,FRI,SAT,SUN
} day;
5)枚举变量的定义的形式3-省略枚举名称，直接定义枚举变量
enum = {
 MON =1,TUE,WED,THU,FRI,SAT,SUN
} day;//这样使用枚举，该枚举类型只能使用一次
6)可以将整数转换为对应的枚举值

函数基本语法:
返回类型 函数名(形参列表){
    执行语句...;//函数体
    return 返回值;//可选
}

头文件的注意事项和细节说明:
1)引用头文件相当于复制头文件的内容
2)源文件的名字可以不和头文件一样，但是为了好管理，一般头文件和源文件名一样
3)include <>和include ""的区别
include <>引用的是编译器的类库路径里面的头文件，用于引用系统头文件
include ""引用的是你程序目录的相对路径中的头文件，如果找不到则到编译器中的系统文件中找该头文件
所以，引用系统头文件，两种形式都可以，但是<>效率高
引用用户头文件，只能使用include ""
4)一个#include命令只能包含一个头文件，多个头文件需要多个#include命令

函数注意事项和细节讨论
1)函数的形参列表可以是多个
2)C语言传递参数可以是值传递，也可以是指针传递，也叫引用传递
3)函数的命名规范，首字母不能是数字，可以采用驼峰法或者下户线法
4)函数的变量是局部的，函数外不生效
5)基本数据类型默认是值传递的，即进行拷贝。在函数内修改，不会影响到原来的值
6)如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，函数内指针的方式操作变量。从效果上看类似引用(即传递指针)
7)C语言 不支持函数重载
8)C语言支持可变参数

变量作用域:
所谓变量作用域，就是指变量的有效范围
1)函数内部声明/定义的局部变量，作用域仅限于函数内部
2)函数的参数，形式参数，被当做该函数内的局部变量，如果与全局变量同名它们会优先使用(编译器使用就近原则)
3)在一个代码块，比如for/if中的局部变量，那么这个变量的作用域就在该代码块
4)在所有函数外部定义的变量叫全局变量，作用域在整个程序有效

C程序的内存布局图
栈区:局部变量
堆区(动态存储区):malloc函数动态分配的数据
静态存储区/全局区:全局变量、静态数据
代码区:存放代码/指令

static关键字
静态局部变量:
1)局部变量被static修饰后，我们成为静态局部变量
2)对应静态局部变量在声明时未赋初值，编译器也会把它初始化为0
3)静态局部变量存储于进程的静态存储区(全局性质)，只会被初始一次，即使函数返回，它的值也会保持不变

静态全局变量:
1)普通全局变量对整个工程可见，其他文件可以使用extern外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了(否则编译器
会认为它们是同一个变量)，静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响
2)定义不需要与其他文件共享的全局变量时，加上static关键字能有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用

静态函数:
1)函数的使用方式与全局变量类似，在函数返回类型前加上static，就是静态函数
2)非静态函数可以在另一个文件中通过extern引用
3)静态函数只能在声明它的文件中可见，其他文件不能引用该函数
4)不同的文件可以使用相同名字的静态函数，互不影响

宏定义:
#define 用一个标识符来表示一个字符串
在预处理阶段，对程序中所有出现的"宏名",系统都会用宏定义中的字符串去代换，这成为"宏替换"或者"宏展开"
宏定义是由源程序中的宏定义命令#define来完成的，宏替换是由预处理程序完成的
可用宏定义表示数据类型，使书写方便
#define UINT unsigned int
void main(){
 UINT a,b;//替换 unsigned int a,b;
}

宏定义表示数据类型和typedef定义数据说明符的区别
1)宏定义只是简单地字符串替换，由预处理器来处理
2)typedef是在编译阶段由编译器处理的，它不是简单地字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型

带参宏定义和函数的区别
1)宏展开仅仅是字符串的替换,不会对表达式进行计算;宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存
2)函数是一段可以重复使用的代码,会被编译,会给它分配内存,每次调用函数,就是执行这块内存中的代码

使用字符指针变量和字符数组两种方法表示字符串的讨论
如果定义了一个字符数组，那么它有确定的内存地址(即字符数组名是一个常量),而定义一个指针变量时,它并未指向某个确定的字符数据,并且可以多次赋值

f5:开始调试、执行到下一个断点
f11:逐句执行代码，会进入到函数体中
f10:逐过程执行(遇到函数，不会进入到函数体)
shift+f11:跳出(跳出某个函数,跳出前，会将函数执行完毕)
shift+f5:终止调试

结构体和结构体变量的区别和联系:
1)结构体是自定义的数据类型，表示的是一种数据类型
2)结构体变量代表一个具体变量
int num1; //int是数据类型，而num1是一个具体的int变量
struct Cat cat1;//Cat是结构体数据类型，而cat1是一个Cat变量
3)Cat就像一个"模板",定义出来的结构体变量都含有相同的成员。也可以将结构体比作"图纸",
,将结构体变量比作"零件",根据同一张图纸生产出来的零件特性都是一样的

结构体声明:
struct 结构体名称{//结构体名首字母大写，比如Cat,Person
    成员列表;
};


创建结构体和结构体变量的方式:
1)方式一
struct Stu{
    char *name;
    int num;
    int age;
    char group;
    float score;
};
struct Stu stu1,stu2;
//定义了两个变量stu1和stu2，它们都是Stu类型，都由5个成员组成
//注意关键字struct不能少

2)方式二
struct Stu{
    char *name;
    int num;
    int age;
    char group;
    float score;
}stu1,stu2;
//在定义结构体Stu的同时，创建了两个结构体变量stu1和stu2

3)方式三(匿名结构体),后面不需要再使用结构体数据类型,定义其他变量
struct {
    char *name;
    int num;
    int age;
    char group;
    float score;
}stu1,stu2;
stu1.name = "tom";.....
//1.该结构体数据类型，没有名，匿名结构体
//2.stu1和stu2就是该结构体的两个变量

成员的获取和赋值:
1)变量名.成员变量
2)结构体名称可以带也可以不带
struct {
    char *name;
    int num;
    int age;
    char group;
    float score;
}stu1={"贾宝玉",11,18,'B',90.50},stu2={"林黛玉",12,16,'A',100};


结构体应用实例
1)声明(定义)结构体，确定结构体名
2)编写结构体的成员
3)编写处理结构体的函数

结构体和共用体的区别:
结构体的各个成员会占用不用的内存，互相之间没有影响;而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员

共用体定义:
1)
union data{
    int n;
    char ch;
    double f;
};
2)
union data{
    int n;
    char ch;
    double f;
}a,b,c;
3)
union {
    int n;
    char ch;
    double f;
}a,b,c;




